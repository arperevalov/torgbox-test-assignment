# Torgbox Test Assignment

Это приложение отображает страницу с часами для двух часовых поясов.
Приложение обладает функцией выбора часового поля для каждого компонента часов.\
\
Приложение написано в качестве решения тестового задания для компании [Torgbox](https://torgbox.ru/).\
Описание задания находится в файле [task.pdf](task.pdf) корневого каталога.

## Содержание
[Использование](#использование) \
[Структура проекта](#структура-проекта) \
[Описание решения](#описание-решения)

## Использование
```
npm install && npm run start
```

## Структура проекта

### /App/Components
В папке **/Clock** — располагаются компоненты для работы с часами.\
Файл **/Clock/ClockContainer.js** — отвечает за связь с Redux, а также работу с fetch-запросами. Компонент используется для вывода количества часов. Этот компонент запускает вычисление времени.\
Файл **Clock.js** — основной компонент часов. В нем проиходит управление временными зонами,
а также подключаются компоненты для непосредственного отображения часов.\
Файлы **/Clock/AnalogClock.js** и **/Clock/DigitalClock.js** — итоговые компоненты для отображения аналоговых и цифровых часов.\
Файлы **Preloader.js** и **Select.js** — копоненты для прелоудера и кастомного селекта.

### /App/Redux
Файл **store.js** — отвечает за создание Store.\
Файл **ClockReducer.js** — является редьюсером для компонентов в папке /Clock.

## Описание решения

Проект использует React для отрисовки приложения, Redux для создания Store, React-redux для связки компонентов со Store.

### Принцип работы часов
1. Контейнерный компонент часов **ClockContainer** создает связь со стейтом и передает пропсы во внутренний компонент **ClockAPI**.
2. **ClockAPI** вызывает такое количество компонентов **Clock**, которое указано в пропсах, которые ему пришли.
3. После монтирования **ClockAPI** вызывает метод **ComponentDidMount**, где запрашивает данные из файла **timezones.json**.
4. Если запрос прошел успешно, то данные передаются в **ClockReducer**, если произошла ошибка, то в редьюсер передается стандартное значение,
где всего один часовой пояс **UTC±0:00**.
5. После обновления данных, компонент обновляется до тех пор, пока в **ClockAPI** не придет массив с часовыми поясами. Все это время пользователь видит **Preloader**. После прихода данных **ClockAPI** запускает метод **updateTime**, с интервалом в 1 секунду создается новый объект **Date**, который передается в **ClockReducer**.*
6. Сам объект **Date**, созданный выше прокидывается в пропсы компоненту **Clock**. Здесь при помощи местного стейта мы создаем новый объект **Date**, только уже передаем в него параметры UTC, где в часах прибавляем ему текущий часовой пояс. Новое время отправляется в дочерние компоненты.

\* Если обратить внимание на предыдущие коммиты, ранее работа со временем была реализована иначе. Для каждого отдельного компонента создавался свой объект **Date** и в каждом компоненте он обновлялся. Признаю, что это была худшая реализация, так как она требовала дополнительных затрат на рендеринг из-за чего приложение имело меньшую отзывчивость. К тому же смена часового пояса происходила ровно через секунду.\
Однако, если подумать, то предыдущая реализация позволяла локально контролировать компонент **Clock**. К примеру, его можно было бы доработать для переиспользования в качестве таймера или секундомера.

### Как пересчитывается время для каждого часового пояса
Значение времени просчитывается в компоненте **ClockAPI** внутри файла **ClockContainer.js** и отправляется в редьюсер **ClockReducer**. Вычисление времени для каждого часового пояса происходит внутри компонента **Clock**.

```js
const timezoneTime = new Date(
    this.props.time.getFullYear(),
    this.props.time.getUTCMonth(),
    this.props.time.getUTCDay(),
    this.props.time.getUTCHours()+this.state.currentTimezone,
    this.props.time.getUTCMinutes(),
    this.props.time.getUTCSeconds())
}
```

### Как работают аналоговые часы
Стрелки часов лежат в обертках, которые вращаются аттрибутом **transform: rotate(DEGREE)**.\
Значения для аттрибута обертки вычисляются на основании времени, которое приходит в пропсах.

```js
let seconds = props.time.getSeconds()*6+180,
    minutes = props.time.getMinutes()*6,
    hours = props.time.getHours()*30
```

### Что представляет собой кастомный селект
С кастомными селектами всегда сложно работать. Нужно учесть множество сценариев, когда им управляет пользователь.\
Я нашел [интересную статью про гибридные селекты](https://web-standards.ru/articles/native-and-custom-select/), по которой и сделал селект.\
Гибридный селект состоит из обычного селекта и кастомного. Кастомный накладывается поверх нативного и эмулирует его поведение.\
При работе с клавиатурой или на устройствах, где отсутствует состояние **hover**, кастомный селект отключается и пользователь видит нативный.

## Спасибо, что посмотрели эту работу
Со мной можно связаться в [Telegram](https://t.me/lovetraindriver) или [по почте](mailto:perevalovartyom@mail.ru).