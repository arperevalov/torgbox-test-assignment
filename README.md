# Torgbox Test Assignment

Это приложение отображает страницу с часами для двух часовых поясов.
Приложение обладает функцией выбора часового поля для каждого компонента часов.\
\
Приложение написано в качестве решения тестового задания для компании [Torgbox](https://torgbox.ru/).\
Описание задания находится в файле [task.pdf](task.pdf) корневого каталога.

## Содержание
[Использование](#использование) \
[Структура проекта](#структура-проекта) \
[Описание решения](#описание-решения)

## Использование
```
npm install && npm run start
```

## Структура проекта

### /App/Components
В папке **/Clock** — располагаются компоненты для работы с часами.\
Файл **/Clock/ClockContainer.js** — отвечает за связь с Redux, а также работу с fetch-запросами. Компонент используется для вывода количества часов.\
Файл **Clock.js** — основной компонент часов. В нем просчитывается время, проиходит управление временными зонами,
а также подключаются компоненты для непосредственного отображения часов.\
Файлы **/Clock/AnalogClock.js** и **/Clock/DigitalClock.js** — итоговые компоненты для отображения аналоговых и цифровых часов.\
Файлы **Preloader.js** и **Select.js** — копоненты для прелоудера и кастомного селекта.\

### /App/Redux
Файл **store.js** — отвечает за создание Store.\
Файл **ClockReducer.js** — является редьюсером для компонентов в папке /Clock\

## Описание решения

Проект использует React для отрисовки приложения, Redux для создания Store, React-redux для связки компонентов со Store.

### Принцип работы часов
1. Контейнерный компонент часов **ClockContainer** создает связь со стейтом и передает пропсы во внутренний компонент **ClockAPI**.
2. **ClockAPI** вызывает такое количество компонентов **Clock**, которое указано в пропсах, которые ему пришли.
3. После монтирования **ClockAPI** вызывает метод **ComponentDidMount**, где запрашивает данные из файла **timezones.json**.
4. Если запрос прошел успешно, то данные передаются в **ClockReducer**, если произошла ошибка, то в редьюсер передается стандартное значение,
где всего один часовой пояс **UTC±0:00**.
5. Далее компонент обновляет значения из Store и передает их в дочерний **Clock**, где начинается работа со временем.
6. Компонент **Clock** обрабатывает в методе **ComponentDidMount** значения, которые пришли из пропсов и запускает метод **updateTime**, где начинает обновляться время для этого компонента*.

\* Время хранится в стейте компонента **Clock** для того, чтобы в дальшейшей разработке мы могли управлять временем компонента вне зависимости от остальных компонентов.
Конечно, если в дальнейшем нам не понадобится раздельное управление временем, то можно переписать логику следующим образом. Компонент **ClockAPI** возьмет на себя управление временем, а само управление временем возьмет на себя **ClockReducer**. Тогда каждого компонента **Clock** будет пересчитываться время в зависимости от выбранной часовой зоны.

### Как пересчитывается время для каждого часового пояса
Значение времени вычисляется в методе **getTimeFromUTC** компонента **Clock**. В аргументы передается значение часового пояса.
1. Для начала мы создаем локальную дату через **new Date**
2. Далее мы создаем новую дату в формате UTC на основе данных из new Date, где в значение часов мы добавляем часовой пояс, который пришел к нам в аргументы.
3. Итоговое полученное время передается в пропсы, к дочерним компонентам, где внутри них мы достаем отдельные значения. К примеру, для аналоговых часов мы высчитываем градус поворота отдельной стрелки.

```js
getTimeFromUTC(currentTimezone) {
    const currentLocalTime = new Date()
    const currentUTCTime = new Date(
        currentLocalTime.getFullYear(),
        currentLocalTime.getUTCMonth(),
        currentLocalTime.getUTCDay(),
        currentLocalTime.getUTCHours() + currentTimezone,
        currentLocalTime.getUTCMinutes(),
        currentLocalTime.getUTCSeconds()
    )
    return currentUTCTime
}
```

### Как работают аналоговые часы
Стрелки часов лежат в обертках, которые вращаются аттрибутом **transform: rotate(DEGREE)**.\
Значения для аттрибута обертки вычисляются на основании времени, которое приходит в пропсах.

```js
let seconds = props.time.getSeconds()*6+180,
    minutes = props.time.getMinutes()*6,
    hours = props.time.getHours()*30
```

### Что представляет собой кастомный селект
С кастомными селектами всегда сложно работать. Нужно учесть множество сценариев, когда им управляет пользователь.\
Я нашел [интересную статью про гибридные селекты](https://web-standards.ru/articles/native-and-custom-select/), по которой и сделал селект.\
Гибридный селект состоит из обычного селекта и кастомного. Кастомный накладывается поверх нативного и эмулирует его поведение.\
При работе с клавиатурой или на устройствах, где отсутствует состояние **hover**, кастомный селект отключается и пользователь видит нативный.\

## Спасибо, что посмотрели эту работу
Со мной можно связаться в [Telegram](https://t.me/lovetraindriver) или [по почте](mailto:perevalovartyom@mail.ru).